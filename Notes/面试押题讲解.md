### HTML部分

#### 1. 你是如何理解 HTML 语义化的？

1.1 HTML语义化的概念

语义化是指**根据内容的结构，选择合适的标签**，便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。

1.2 HTML语义化的作用

去掉或 CSS 样式丢失的时候,也能让页面呈现清晰的结构，增强页面的可读性。

方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以有意义的方式来渲染网页。

和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重。

在团队中大家都遵循W3C标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。

1.3 HTML语义化的方法

1. 根据文档上下文结构合理的选用最适合表达当前语义的标签；
2. 尽可少使用无语义的标签 <div> 和 <span>；
3. 不要使用带有样式的标签，比如：`<b>` 、 `<u>` 、 `<font>` 等，使用 CSS 设置
4. 标题标签的使用应该根据重要性逐级递减，没有断层，并且一个页面只能有一个 <h1>；
5. 提高关键词密度，如图像的替代文本 alt，提示文本 title；
6. 正确使用内容容器，比如段落 <p>，列表 <ul>, <ol>, <li>, <dl>, <dt>, <dd>;
7. 需要强调的文本，可以使用 `<strong>` 或 `<em>` 标签（浏览器默认样式，能用 CSS 设置就不用）， `<strong>` 默认样式是加粗（不用 `<b>`），`<em>` 是斜体（不用 `<i>`）
8. 每个 <input> 标签对应的说明文本都需要使用 <label> 标签，通过为 <input> 设置 id 属性，并且在 <lable> 标签中设置 for=id 使说明文本和对应的 <input> 关联。

####  2 . meta viewport 是做什么用的，怎么写？

1.  单位

   在讨论viewport之前，我们需要了解一些单位的概念；

   * 设备像素/物理像素(physical pixel)

   是指屏幕的实际物理像素点，例如iPhone plus是1920 * 1080的像素分辨率，那么代表横向有1080个物理像素点，纵向有1920个物理像素点。

   * Css 像素（css pixel) / 独立像素点（density independent pixels -dip)

   CSS像素是抽象的概念，是web编程中的概念，是独立于设备，用于逻辑上衡量像素的单位，所以又叫独立像素点，即dip(有时也缩写dp)。

   * 屏幕尺寸

   指屏幕的对角线长度，单位是英寸（inch），1 英寸 = 2.54 厘米。常见屏幕尺寸有 5.0、5.5 和 6.0 等。

   + 屏幕像素密度（pixels per inch - ppi）

   指屏幕上每英寸可以显示的物理像素点的数量。比如 iPhone6 Plus 是 5.5 英寸，分辨率（也就是物理像素）是 1920*1080 像素，那么它的ppi = √(1920^2+1080^2) / 5.5 ≈ 401ppi

   + 设备像素比

   是指物理像素点和密度像素点（CSS 像素点）之间的比值，window.devicePixelRatio = 物理像素 / dip.

2.  viewport

   viewport指的是web页面上可见的区域。

   viewport 的大小是和设备相关的，在移动端例如手机上，viewport 的大小是比 PC 端要小的，一般无论手机还是平板，默认的 viewport 大小都是 980px 。

   ```<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">```

   其中 device-width是指这个设备最理想的可见宽度，即viewport宽度。iPhone6之前的device-width都是320px,iPhone6之后的宽度是375px，iPhone6 plus 是414px，而device-width是和css像素是相同的。也就说，web页面中的css像素和device-width相同时就能铺满整个屏幕的宽度。

   安卓手机的 device-width 有320px、360px 和 384px 等等，不同的设备 device-width 是不一样的。

   initial-scale=1.0是指的是初始化时候缩放比列是1，也就是不缩放

   maximum-scale=1.0是指最大缩放大小的比例，因为有上面那一行这行其实可以省略。

   user-scalable=0是指禁止用户进行缩放。

   **在设计人员为移动端设计页面的时候经常可以听到2倍图和3倍图这些词语，这又是什么意思呢，我们以 iPhone6 举例**：

   iPhone6 的分辨率（也就是物理像素）是 1334*750 像素，它的 device-width 是 375px 。

   如果我们将屏幕横向分成 375 份，CSS 中 1px 占用的1份，因为屏幕就那么大，CSS中 width 等于 375px 时横向就会占满全屏，但是实际上**存在的物理像素点横向是750个** ，所以在我们写 CSS 时 1px 对应到屏幕上是占用了2个物理像素点。

   如果我们不写 **width=device-width** 这一句的话，默认 viewport 宽是 980px 。那么把 iPhone6 的屏幕横向分成980份，CSS 中 1px 占用1份，但是真正的像素点横向只有750个，这就意味着，实际上渲染出来的宽度是 75/98 个像素大小（只是理论上）。

   设计人员在设计原型图的时候以 750px 的宽度为基准，我们在写 CSS的时候缩写一半来使用，但是在渲染的时候 1px 等于 2px 的物理像素，所以整个图片还是按 750px 的宽度来显示的，不会失真。

   如果设计人员以 375px 的宽度为基准，那么我们在使用的时候直接把设计图中的像素宽度用在 CSS 中，那么在渲染的时候，1px 等于 2px 的物理像素，相当于图片会放大2倍，就会产生失真。

3. #### 总结

   在添加 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"> 之后，移动端的 viewport 宽度会从默认的 980px 变成各个设备的 device-width 。

#### 3.  有哪些 HTML 5 标签？

​	**<article>**标签定义外部的内容。比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文		本，或者是来自论坛的文本。亦或是来自其他外部源内容。

**<aside>**标签定义 article 以外的内容。aside 的内容应该与 article 的内容相关。

```<aside>Aside 的内容是独立的内容，但应与文档内容相关。</aside>```

```<audio> 标签定义声音，比如音乐或其他音频流。```

```<canvas> 标签定义图形，比如图表和其他图像。这个 HTML 元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。```

语义化的header和footer

```
<header></header>
<footer></footer>
```

图形元素：

```html

<figure>
    <img src="path/to/image" alt="About image" />
    <figcaption>
        <p>This is an image of something interesting.</p>
    </figcaption>
</figure>
```

脚本和链接无需type属性：

```html
<link rel="stylesheet" href="style/stylesheet.css" />
<script src="js/script.js"></script> 
```

hgroup：

在HTML5中，有许多新引入的元素，hgroup就是其中之一。假设我的网站名下面紧跟着一个子标题，我可以用<h1>和<h2>标签来分别定义。然而，这种定义没有说明这两者之间的关系。而且，h2标签的使用会带来更多问题，比如该页面上还有其他标题的时候。
在HTML5中，我们可以用hgroup元素来将它们分组，这样就不会影响文件的大纲。

```html
<header>
    <hgroup>
      <h1> Recall Fan Page </h1>
      <h2> Only for people who want the memory of a lifetime. </h2>
    </hgroup>
</header>
```

标记元素：mark

它可以用来显示搜索引擎搜索后关键词。

```html
<h3> Search Results </h3>
<p> They were interrupted, just after Quato said, <mark>"Open your Mind"</mark> </p>
```

必要属性：required

这个属性指定用户在提交表单之前必须为该元素填充值. 当type属性是hidden,image或者按钮类型(submit,reset,button)时不可使用

```html
<input type="text" name="someInput" required>
<input type="text" name="someInput" required="required">
```

当文本框被指定必需时，如果空白的话表格就不能提交。下面是一个如何使用的例子。

```html
<form method="post" action="">
    <label for="someInput"> Your Name: </label>
    <input type="text" id="someInput" name="someInput" placeholder="Douglas Quaid" required>
    <button type="submit">Go</button>
</form>
```

如果输入内容空且表格被提交，输入框将被高亮显示。

Autofocus自动对焦属性：

HTML5的解决方案消除了对JavaScript的需要。如果一个特定的输入应该是“选择”或聚焦，默认情况下，我们现在可以利用自动聚焦属性。

```html
<input type="text" name="someInput" placeholder="Douglas Quaid" required autofocus>
```

Audio: 音频支持

```html
<audio autoplay="autoplay" controls="controls">
     <source src="file.ogg" />
     <source src="file.mp3" />
     <a href="file.mp3">Download this file.</a>
</audio> 
```

当使用<audio>元素时请记得包含两种音频格式。FireFox想要.ogg格式的文件，而Webkit浏览器则需要.mp3格式的。和往常一样，IE是不支持的，且Opera 10及以下版本只支持.wav格式。

Video: 另一种音频支持

HTML5中不仅有<audio>元素，而且还有<video>。然而，和<audio>类似，HTML5中并没有指定视频解码器，它留给了浏览器来决定。虽然Safari和Internet Explorer9可以支持H.264格式的视频，Firefox和Opera是坚持开源Theora 和Vorbis格式。因此，指定HTML5的视频时，你必须提供这两种格式。

```html
<video controls preload>
    <source src="cohagenPhoneCall.ogv" type="video/ogg; codecs='vorbis, theora'" />
    <source src="cohagenPhoneCall.mp4" type="video/mp4; 'codecs='avc1.42E01E, mp4a.40.2'" />
    <p> Your browser is old. <.a href="cohagenPhoneCall.mp4">.Download this video instead.</a> </p>
</video>
```

视频预加载：

当用户访问页面时这一属性使得视频得以预载。为了实现这个功能，可以在<video>元素中加上preload="preload"或者只是preload。

```html
<video preload >
```

视频显示控制条：controls

如果你使用过上面的每一个提到的技术点，你可能已经注意到，使用上面的代码，视频仅仅显示的是张图片，没有控制条。为了渲染出播放控制条，我们必须在video元素内指定controls属性。

```html
<video preload controls>
```

正则表达式：

HTML5中新的pattern属性让我们能够在标签处直接插入一个正规表达式。

```html
<form action="" method="post">
    <label for="username">.Create a Username: </label>
    <input type="text" name="username" id="username" placeholder="4 <> 10" pattern="[A-Za-z]{4,10}" autofocus required>
    <button type="submit">.Go </button>
</form>
```

Range Input:

HTML5引用的range类型可以创建滑块，它接受min, max, step和value属性 
可以使用css的:before和:after来显示min和max的值

```html
<input type=”range” name=”range” min=”0″ max=”10″ step=”1″ value=”"> 
input[type=range]:before { content: attr(min); padding-right: 5px; 
} 
input[type=range]:after { content: attr(max); padding-left: 5px;} 
```

##### 新增接口

HTML5为了帮助创建Web App，引入了一些新的接口：

- 媒体标签video和audio的播放流程控制、同步多个媒体标签、字幕等接口
- 表单限制验证接口（如setCustomValidity）
- 引入应用缓存机制，允许Web App离线的API
- 允许Web App注册为对应协议或媒体类型的处理应用的APP的API。（即registerProtocolHandler和registerContentHandler）
- 引入contenteditable属性，允许编辑任意元素的接口
- 暴露会话历史、允许使用脚本无刷新更新页面URL（History接口）
- base64转换API（atob()及btoa()）
- 处理搜索服务提供方的接口（AddSearchProvider()及IsSearchProviderInstalled()）
- External接口
- 打印文档的接口（print()）
  （译注：下列接口是很早就有，属于BOM中的共识部分，直到HTML5才加入标准）
- 暴露文档URL、允许使用脚本切换、刷新页面的接口（Location接口）
- 基于时间的回调接口（setTimeout()及setInterval()）
- 提供给用户的提示接口（alert()，confirm()，prompt()）
- Window接口
- Navigator接口

##### 修改的接口

如下DOM 2的接口已被改动：

- document.title的返回值将会折叠多个空格符
- document.domain允许赋值，因此可以改变文档的script origin
- document.open()可以清空文档（如果调用时仅有两个或以下参数），或像是window.open()一样表现（如果调用时有三个或四个参数）。在前种调用方式下，抛出一个XML异常
- document.close()、document.write()、document.writeln()抛出一个XML异常。后两者允许可变参数，他们可以在文档解析阶段往文档流中加入文本，并隐式调用document.open()。在一些情形下，他们都可能会被忽略
- document.getElementsByName()将返回满足name符合参数的所有HTML元素
- HTMLFormElement的elements接口将返回HTMLFormControlsCollection，包括button, fieldset, input,keygen, object, output, select及textarea
- HTMLSelectElement的add()接口允许第二个参数为数字
- HTMLSelectElement的remove()接口在参数越界的时候，将删除集合中第一个元素
- 在所有的HTML元素中都可以调用click()、focus()及blur()接口了
- a及areastringify为它们的href属性
  （译注：意味着HTMLAnchorElement和HTMLAreaElement对应的toString方法返回它们的href属性）

##### Document 扩展

DOM Level 2中有个HTMLDocument接口，继承自Document接口，并提供了文档内部的元素（仅局限于HTML范畴内）访问接口。
HTML5将这些成员移动到了Document接口中，并在特定方向上拓展了它。由于各类文档（译注：XML、HTML5、SVG等等文档）都使用了Document接口，而HTML5范畴内的元素在所有类别的文档中都可用，因此这些接口在SVG等文档中都可以很好的运作。

此外，Document接口还有一些新成员：

- location、lastModified及readyState：用于帮助管理文档的元数据(metadata)
- dir、head、embeds、plugins、scripts：用于获取DOM树的不同部分
- activeElement及hasFocus接口，用于判断一个元素是否获得了焦点
- 文档编辑接口：designMode、execCommand()、queryCommandEnabled()、queryCommandIndeterm()、queryCommandState()、queryCommandSupported()、queryCommandValue()
- 所有的IDL事件处理属性。此外，onreadystatechange是唯一一个在Document上才有效的接口
  在脚本中修改了HTMLDocument原型的那部分还是可以正常运转的，由于window.HTMLDocument也将返回Document接口。

##### HTMLElement 扩展

HTMLElement接口也在HTML5中得到了扩展：

- 用于得到data-*的属性的接口dataset
- click()、focus()、blur()接口允许脚本模拟用户点击与切换焦点
- accessKeyLabel给予UA赋予该元素的快捷键，开发可以通过accesskey属性来影响UA的该行为
- isContentEditable返回元素是否可以编辑
- 全部的IDL事件处理属性
- 得到元素属性的接口如translate、hidden、tabIndex、accessKey、contentEditable、spellcheck、style
  （译注：DOM Level 2仅建议采用Element接口上的setAttribute和getAttribute来获取或设置HTML Attribute，HTML5的这些定义扩展了HTML Attribute的范围，让它们可以像DOM Property一样set和get——UA早已广泛支持）
- 有些之前在HTMLElement上定义接口被移动到了Element接口中：id、className、classList、getElementsByClassName()
  （译注：扩展了DOM Level 2上的Element接口定义，可以直接set/get id等属性值了——UA早已广泛支持）

##### 其他扩展接口

DOM Level 2中的其它接口也得到了扩展。

| 接口                  | 新增接口                                                     |
| --------------------- | ------------------------------------------------------------ |
| HTMLOptionsCollection | legacy caller、setter creator、add()、remove()、selectedIndex |
| HTMLFormElement       | 通过name或index索引的getter、checkValidity()                 |
| HTMLSelectElement     | getter、setter creator、item()、namedItem()、labels、selectedOptions及各种validate接口函数 |
| HTMLOptionElement     | 构造器new Option()                                           |
| HTMLInputElement      | files、height、indeterminate、list、valueAsDate、valueAsNumber、width、stepUp()、stepDown()、labels、文本选取区域API及各种validate接口函数 |
| HTMLTextAreaElement   | textLength、labels、文本选取区域API及各种validate接口函数    |
| HTMLButtonElement     | labels及各种validate接口函数                                 |
| HTMLLabelElement      | control                                                      |
| HTMLFieldSetElement   | type、elements及各种validate接口函数                         |
| HTMLAnchorElement     | relList、text                                                |
| HTMLLinkElement       | relList                                                      |
| HTMLAreaElement       | relList                                                      |
| HTMLImageElement      | 构造器new Image()、naturalWidth、naturalHeight、complete     |
| HTMLObjectElement     | contentWindow、legacy caller及各种validate接口函数           |
| HTMLMapElement        | images                                                       |
| HTMLTableElement      | createTBody()                                                |
| HTMLIFrameElement     | contentWindow                                                |

此外：

- HTMLLinkElement和HTMLStyleElement实现了CSSOM中的LinkStyle接口
- HTMLAnchorElement、HTMLLinkElement和HTMLAreaElement实现了URLUtils接口

##### 废弃接口

- 在HTML5中已被废弃的属性，其对应IDL属性接口也将被废弃。如bgColor已被废弃，那么HTMLBodyElement之上的IDL属性接口bgcolor也被废弃
- 在HTML5中已被废弃的元素，其对应接口也被废弃，包括HTMLAppletElement, HTMLFrameSetElement,HTMLFrameElement, HTMLDirectoryElement及HTMLFontElement、HTMLBaseFontElement
- 由于HTML解析器将isindex替代为其他元素了，HTMLIsIndexElement接口被废弃
- 一些成员属性从HTMLDocument接口移动到了Document接口，因此在原来的HTMLDocument下被废弃：anchors和applets。

### CSS 部分

#### 1. 两种盒模型。

涉及知识点(层层递进):

1. 基本概念：标准模型+ IE模型(区别)
2. CSS如何设置这两种模型
3. JS如何设置获取盒子模型对应的宽和高
4. 实例题(根据盒模型解释边距重叠)
5. BFC(边距重叠解决方案)

##### 1. 1  基本概念：标准盒模型和IE盒模型

**什么是盒模型：**盒模型又称框模型（Box Model）,包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。如图：

![标准盒模型](<https://image-static.segmentfault.com/251/829/2518294357-5b1b70de45a8c>)

**从上图可以看到标准 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。**

**IE模型元素宽度width=content+padding**，高度计算相同

![IE盒模型](<https://image-static.segmentfault.com/143/984/1439846899-5b1b70fdb2c3a>)

​	   **从上图可以看到 IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型		不同的是：IE 盒子模型的 content 部分包含了 border 和 padding。**

​		**标准模型元素宽度width=content**，高度计算相同.

##### 1.2  CSS如何设置获取两种盒模型

通过css3新增的属性 `box-sizing: content-box | border-box`分别设置盒模型为标准模型（`content-box`）和IE模型（`border-box`）。

```css
.content-box {
  box-sizing:content-box;
  width: 100px;
  height: 50px;
  padding: 10px;
  border: 5px solid red;
  margin: 15px;
}
```

![示意图](https://upload-images.jianshu.io/upload_images/79178-f0a78b1c458cf16e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`.content-box`设置为标准模型，它的元素宽度width=100px。

```css
.border-box {
  box-sizing: border-box;
  width: 100px;
  height: 50px;
  padding: 10px;
  border: 5px solid red;
  margin: 15px;
}
```

![示意图](https://upload-images.jianshu.io/upload_images/79178-15ee23e259ba96a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`.border-box`设置为IE模型，它的元素宽度width=content + 2 *padding + 2* border = 70px + 2 *10px + 2* 5px = 100px。

##### 1.3  Javascript如何获取盒模型的宽和高

1. `dom.style.width/height` 只能取到行内样式的宽和高，style标签中和link外链的样式取不到。
2. `dom.currentStyle.width/height` 取到的是最终渲染后的宽和高，只有IE支持此属性。
3. `window.getComputedStyle(dom).width/height` 同（2）但是多浏览器支持，IE9以上支持。
4. `dom.getBoundingClientRect().width/height` 也是得到渲染后的宽和高，大多浏览器支持。IE9以上支持，除此外还可以取到相对于视窗的上下左右的距离

##### 1.4  外边距重叠

当两个垂直外边距相遇时，他们将形成一个外边距，合并后的外边距高度等于两个发生合并的外边距的高度中的较大者。**注意**：只有普通文档流中块框的垂直外边距才会发生外边距合并，行内框、浮动框或绝对定位之间的外边距不会合并。

![示意图](https://upload-images.jianshu.io/upload_images/79178-7f94accd5a09b830.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

看下面例子：

```html
    <section id="sec">
        <style media="screen">
            * {
                margin: 0;
                padding: 0;
            }
            #sec {
                background: #f00;
            }
            .child {
                height: 100px;
                margin-top: 10px;
                background: yellow;
            }
        </style>
        <article class="child"></article>
    </section>
```

这里父元素section的高度是多少呢，100px，但是我们给section设置overflow:hidden后高度就变成110px，这是为什么呢，其实这里我们给父元素创建了BFC。什么是BFC,请看下面的介绍。

##### 1.5  BFC(Block Formatting Context)：块级格式化上下文

BFC决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当设计到可视化布局的时候，BFC提供了一个环境，HTML元素在这个环境中按照一定的规则进行布局。一个环境中的元素不会影响到其他环境中的布局。

BFC的原理（渲染规则）：

1. BFC元素垂直方向的边距会发生重叠。属于不同BFC外边距不会发生重叠
2. BFC的区域不会与浮动元素的布局重叠。
3. BFC元素是一个独立的容器，外面的元素不会影响里面的元素。里面的元素也不会影响外面的元素。
4. 计算BFC高度的时候，浮动元素也会参与计算(清除浮动)。

如何创建BFC：

1. overflow不为visible;
2. float的值不为none；
3. position的值不为static或relative；
4. display属性为inline-blocks,table,table-cell,table-caption,flex,inline-flex;

举几个例子看看：

1. 利用原理2可实现左图右文之类的效果：

   ```html
   <img src='image.png'>
   <p>我是超长的文字<p>
   ```

   ```css
   img {
       float:left
   }
   p {
       overflow:hidden
   }
   ```

   还有：

   ```html
       <section id="layout">
           <style media="screen">
               #layout {
                   background: red;
               }
               #layout .left {
                   float: left;
                   width: 100px;
                   height: 100px;
                   background: pink;
               }
               #layout .right {
                   height: 110px;
                   background: #ccc;
               }
           </style>
           <div class="left"></div>
           <div class="right"></div>
       </section>
   ```

   效果如下:

   ![示意图](https://upload-images.jianshu.io/upload_images/79178-49fffb573bff36e3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)

   写过前端页面的我们肯定遇到过这种情况，这里其实是浮动元素叠在 `.right` 元素的上面，这就不符合我们左右布局的意图了。如果我们想让.right元素不会延伸到 float元素怎么办,其实我们在.right元素上加 `overflow:hidden` （用其他的方式创建BFC也可以）创建BFC就可以解决。因为BFC不会与浮动元素发生重叠。

   ![示意图](https://upload-images.jianshu.io/upload_images/79178-76b7cc717286a34f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)

   

2.  利用原理4可以实现浮动元素父级元素塌陷的问题

   ```html
   <div class='parent'>
       <div class='float'>浮动元素</div>
   </div>
   ```

   ```css
   .parent {
       overflow:hidden;
   }
   .float {
       float:left;
   }
   ```

3.  利用原理1可以实现元素垂直方向的边距会发生重叠的问题

   ```html
       <section id="margin">
           <style>
               * {
                   padding: 0;
                   margin: 0;
               }
               #margin {
                   background: pink;
                   overflow: hidden;
               }
               p {
                   margin: 15px auto 25px;
                   background: red;
               }
           </style>
           <p>1</p>
           <div style="overflow: hidden">
               <p>2</p>
           </div>
           <p>3</p>
           <p>4</p>
       </section>
   ```

   请看这里的第二个p元素<p>2</p>他被一个父元素包裹，并且父元素有 `overflow:hidden` 样式，前面的如何创建BFC的第一条就说了 `overflow:hidden` 可以创建一个BFC。结果如下图所示。

   ![示意图](https://upload-images.jianshu.io/upload_images/79178-f90cd59191f3cc96.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)

   看这里的2，它的上下外边距都没有与1和3发生重叠，但3与4外边距发生了重叠。这就解释了BFC创建了一个独立的环境，这个环境中的元素不会影响到其他环境中的布局，所以BFC内的外边距不与外部的外边距发生重叠。

   

#### 2. 如何垂直居中

```html
<div class="parent">
  <div class="child"></div>
</div>
```
 1. flex

    ```css
    div.parent {
        display: flex;
        justify-content: center;
        align-items: center;
    }
    ```

 2.  transform 或者 absolute

    ```css
    div.parent {
        position: relative; 
    }
    div.child {
        position: absolute; 
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);  
    }
    /* 或者 */
    div.child {
        width: 50px;
        height: 10px;
        position: absolute;
        top: 50%;
        left: 50%;
        margin-left: -25px;
        margin-top: -5px;
    }
    /* 或 */
    div.child {
        width: 50px;
        height: 10px;
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto;
    }
    ```

3.   grid

   ```css
   div.parent {
       display: grid;
   }
   div.child {
       justify-self: center;
       align-self: center;
   }
   ```

4.  inline-block

   ```css
   div.parent {
       font-size: 0;
       text-align: center;
       &::before {
           content: "";
           display: inline-block;
           width: 0;
           height: 100%;
           vertical-align: middle;
       }
   }
   div.child{
     display: inline-block;
     vertical-align: middle;
   }
   ```

###  JS 部分

##### 1. 手写函数防抖和函数节流

```javascript
/**
 * 防抖函数
 * @param {function} func 执行函数
 * @param {number} wait 延迟执行时间
 * @param {boolen} immediate 是否立刻执行
 */
function debounce(func, wait = 50, immediate = false) {
  let timer, context, args;

  const later = () =>
    setTimeout(() => {
      timer = null;
      if (!immediate) {
        func.apply(context, args);
        context = null;
        args = null;
      }
    }, wait);

  return function realPart(...params) {
    if (!timer) {
      timer = later();
      if (immediate) {
        func.apply(this, params);
      } else {
        context = this;
        args = params;
      }
    } else {
      clearTimeout(timer);
      timer = later();
    }
  };
}
```

节流函数

```javascript
function throttle(func, wait, options = {}) {
  let result, timeout, context, args;
  let previous = 0; // 之前的时间戳

  const later = () => {
    previous = options.leading === false ? 0 : +new Date();
    timeout = null;
    result = func.apply(context, args);
    context = null;
    args = null;
  };

  return function throttled(...params) {
    const now = +new Date();
    if (!previous && options.leading === false) {
      previous = now;
    }
    const remaining = wait - (now - previous);
    context = this;
    args = params;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) {
        context = null;
        args = null;
      }
    } else if (!timeout && options.trailing !== false) {
      // 当不设置options的时候，trailing为undefine
      //undefine !== false => true
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
}
```

##### 2. 理解XMLHttpRequest对象——手写个ajax

```javascript
function ajax (options) {
        let url = options.url
        const method = options.method.toLocaleLowerCase() || 'get'
        const async = options.async != false // default is true
        const data = options.data
        const xhr = new XMLHttpRequest()

        if (options.timeout && options.timeout > 0) {
            xhr.timeout = options.timeout
        }

        return new Promise ( (resolve, reject) => {
            xhr.ontimeout = () => reject && reject('请求超时')
            xhr.onreadystatechange = () => {
                if (xhr.readyState == 4) {
                    if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                        resolve && resolve(xhr.responseText)
                    } else {
                        reject && reject()
                    }
                }
            }
            xhr.onerror = err => reject && reject(err)

            let paramArr = []
            let encodeData
            if (data instanceof Object) {
                for (let key in data) {
                    // 参数拼接需要通过 encodeURIComponent 进行编码
                    paramArr.push( encodeURIComponent(key) + '=' + encodeURIComponent(data[key]) )
                }
                encodeData = paramArr.join('&')
            }

            if (method === 'get') {
                  // 检测 url 中是否已存在 ? 及其位置
                const index = url.indexOf('?')
                if (index === -1) url += '?'
                else if (index !== url.length -1) url += '&'
                  // 拼接 url
                url += encodeData
            }

            xhr.open(method, url, async)
            if (method === 'get') xhr.send(null)
            else {
                // post 方式需要设置请求头
                xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=UTF-8')
                xhr.send(encodeData)
            }
        } )
    }
```

##### 3. 什么是 JSONP，什么是 CORS，什么是跨域？

Web 开发中，跨域请求是个经常碰到的问题，因为涉及到网站安全，所以浏览器是拒绝跨域请求的。通常解决    跨域会采用 [JSONP](https://en.wikipedia.org/wiki/JSONP)(JSON with Padding) 和 [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)(Cross-Origin Resource Sharing)。

首先理清一个经常会被混淆的概念，AJAX(Asynchronous JavaScript and XML) 和跨域请求是两个不同的概念，AJAX 是异步请求和解析处理 XML 文档的方式，它在服务器端没有提供支持（CORS 是一种解决方案）的前提下，也是无法跨域的。

1.  跨域请求

   跨域请求，顾名思义，就是从 A 地址向非同源的 B 地址发起了请求。参考 MDN 上对同源的定义:

   如果两个页面拥有相同的协议（protocol），端口（如果指定）和主机，那么这两个页面就属于同一个源（origin）。

   MDN 给了同源检测的示例，如果是相对 http://store.company.com/dir/page.html，那么

|                        URL                        | 结果 |    原因    |
| :-----------------------------------------------: | :--: | :--------: |
|    <http://store.company.com/dir2/other.html>     | 成功 |            |
| <http://store.company.com/dir/inner/another.html> | 成功 |            |
|      <https://store.company.com/secure.html>      | 失败 |  协议不同  |
|    <http://store.company.com:81/dir/etc.html>     | 失败 |  端口不同  |
|     <http://news.company.com/dir/other.html>      | 失败 | 主机名不同 |

严格的说，浏览器并不是拒绝所有的跨域请求，否则如果想从百度搜索结果页跳转到其他页面就是个伪命题，实际上拒绝的是跨域的读操作。浏览器的同源限制策略是这样执行的：

- 通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向；
- 通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 `img`、`script` 标签；
- 通常浏览器不允许跨域读操作（Cross-origin reads）。

对于跨域资源的嵌入，实际开发中用的非常频繁，从外部引入 Javascript、css、img 这些静态文件，都是被浏览器接受的。

下面对浏览器的同源策略做个测试，探探究竟。

```javascript
// cross-origin request
var url = "http://search.jd.com/Search?keyword=python&enc=utf-8&wq=python";
var request = new XMLHttpRequest();
request.open("GET", url);
request.send(null);
```

浏览器控制台会出现错误信息（信息中的 Origin 为 null 是因为我是用浏览器直接打开 html，而不是通过 http server 访问 html）：

XMLHttpRequest cannot load <http://search.jd.com/Search?keyword=python&enc=utf-8&wq=python>. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘null’ is therefore not allowed access.

该请求来源的 Origin 不在可允许范围内，这种情况就是跨域请求被拒。下面是一个简单的本地 http server：

```javascript
`// local http server writtern by Node.jsvar http = require('http');var port = 8080; function handleRequest(request, response){    response.end('Hello');    console.log('request url: ' + request.url);}var server = http.createServer(handleRequest);server.listen(PORT, function(){    console.log("Server listening on: http://localhost:%s", port);});`
```

`node simple-server.js` 运行，把请求的 URL 改成 [http://localhost:8080，可以看到命令行终端输出日志，这就表明，请求实际上是从浏览器发出了，服务器也接收到了请求，但是浏览器在读取跨域返回的数据时被拒绝了。这就印证了](http://localhost:8080，可以看到命令行终端输出日志，这就表明，请求实际上是从浏览器发出了，服务器也接收到了请求，但是浏览器在读取跨域返回的数据时被拒绝了。这就印证了/) MDN 文档上说明的，浏览器不允许跨域读操作。

2.  JSONP

    JSONP 并不在 HTML 的标准里，而是开发者为了实现跨域请求而创造的一个 trick。在 HTML 中，可以通过 “src”、”img” 标签引入非同源的静态资源，这就给 JSONP 的实现提供了可能。

   JSONP 的实现很简单，需要客户端和服务端配合。客户端在 HTML 中动态生成 `script` 标签，在 “src” 中引入请求的 URL + 回调函数，这样请求服务器返回的数据会交由回调函数处理，这样就实现了跨域读请求；服务端在接收到客户端请求后，首先取得客户端要回调的函数名，再生成 JavaScript 代码段返回给浏览器，浏览器在获取到返回结果后直接调用回调函数完成任务。

   手写一段简陋的 JS 代码演示下 JSONP 的整个流程：

   ```javascript
   function handleCallback(result) {
       console.log(result.message);
   }
   
   var jsonp = document.createElement('script');
   var ele = document.getElementById('demo');
   jsonp.type = 'text/javascript';
   jsonp.src = 'http://localhost:8080?callback=handleCallback';
   ele.appendChild(jsonp);
   ele.removeChild(jsonp);
   ```

   JSONP 只支持 GET 请求，而且需要服务器端来配合，如果服务器端返回一段恶意代码，客户端也会毅然决然的执行……JSONP 是一个伟大的创造，但还不够好。

3.  CORS

   CORS 是W3C 推荐的一种新的官方方案，能是服务器支持 XMLHttpRequest 的跨域请求。CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源。

   浏览器对 CORS 的使用场景做了区分，有简单请求和非简单请求之分。MDN 对简单请求的定义条件是：

   - 只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种；
   - 不会使用自定义请求头；

   浏览器（支持 CORS）对简单的跨域请求，会在请求头里加上 `Origin` 字段，向服务器说明请求源信息，包括协议、域名和端口，由服务器判断请求源是否在允许的域中。

   编写一个简单请求，跨域获取信息：

   ```javascript
   var url = "https://ipinfo.io/54.169.237.109/json?token=iplocation.net";
   $.ajax({
       url: url
   });
   ```

   查看请求头信息：

   ```text
   `Accept:*/*Accept-Encoding:gzip, deflate, sdch, brAccept-Language:zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4Cache-Control:max-age=0Connection:keep-aliveDNT:1Host:ipinfo.ioOrigin:https://isudox.comReferer:https://isudox.com/test.htmlUser-Agent:Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/52.0.2743.116 Chrome/52.0.2743.116 Safari/537.36`
   ```

   浏览器自动给请求头添加了 `Origin` 字段，请求的服务端如果允许来自该 `Origin` 来源的请求，就会在响应头中添加 `Access-Control-Allow-Origin` 字段，参考上面请求的响应头：

   ```text
   Access-Control-Allow-Origin:*
   Connection:keep-alive
   Content-Encoding:gzip
   Content-Length:231
   Content-Type:application/json; charset=utf-8
   Server:nginx/1.8.1
   X-Content-Type-Options:nosniff
   ```

   `Access-Control-Allow-Origin` 字段表明服务器接受来自任何请求源的跨域请求。因此，通过客户端的 `Origin` 和 服务端的 `Access-Control-Allow-Origin` 实现了跨域的 XMLHttpRequest 请求。

   MDN 对非简单请求的定义条件为:

   - 以 GET、HEAD、或者 POST 以外的方法发起，或者是请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型；
   - 使用自定义请求头（比如添加诸如 X-PINGOTHER）

   非简单请求会先向服务器发送一个 `OPTIONS` 的“预请求”（preflight），来确认该跨域请求是否能被服务端允许，如果允许，则继续发送费简单请求，否则，XMLHttpRequest 的 onerror 回调函数会捕获到错误信息。

   编写一个非简单请求：

   ```javascript
   var url = 'http://aruner.net/resources/access-control-with-post-preflight/';
   var xhr = new XMLHttpRequest();
   xhr.open('POST', url, true);
   xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
   xhr.setRequestHeader('Content-Type', 'application/xml');
   xhr.send();
   ```

   预请求的请求头：

   ```
   OPTIONS /resources/post-here/ HTTP/1.1
   Host: bar.com
   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
   Connection: keep-alive
   Origin: http://foo.example
   Access-Control-Request-Method: POST
   Access-Control-Request-Headers: X-PINGOTHER
   ```

   预请求由 `OPTIONS` 请求发出，`Access-Control-Request-Method` 字段标识跨域请求的方式，`Access-Control-Request-Headers`字段标识跨域请求的自定义请求头名称，再加上 `Origin` 字段，服务端就能判断还没正式发过来的跨域请求是否是安全可允许的。

   如果服务端允许该跨域请求，其响应头类似如下形式：

   ```
   `HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://foo.comAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHERAccess-Control-Max-Age: 1728000Vary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain`
   ```

   其中，响应头中的 `Access-Control-*` 字段的具体含义如下：

   - `Access-Control-Allow-Origin` 标识可接受的跨域请求源；
   - `Access-Control-Allow-Methods` 标识可接受的跨域请求方法；
   - `Access-Control-Allow-Headers` 标识可接受的跨域请求自定义头；
   - `Access-Control-Max-Age` 标识本次预请求的有效时间（秒），期间内无需再发送预请求；

   如果拒绝该跨域请求，错误信息也会被 `onerror` 回调捕获。

   XMLHttpRequest 请求可以发送凭证请求（HTTP Cookies 和验证信息），通常不会跨域发送凭证信息，但也有一些情况需要打通不同的登录态，可以把 XMLHttpRequest 的 `withCredentials` 设置为 `true`，这样浏览器就能跨域发送凭证信息。

   ```javascript
   var xhr = new XMLHttpRequest();
   xhr.withCredentials = true;
   ```

   服务端返回的响应头中的 `Access-Control-Allow-Credentials` 字段存在且为 `true` 时，浏览器才会将响应结果传递给客户端程序。另外，`Access-Control-Allow-Origin` 必须指定请求源的域名，否则响应失败。

   ```text
   `HTTP/1.1 200 OKAccess-Control-Allow-Origin: http://foo.comAccess-Control-Allow-Credentials: trueSet-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMTKeep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain`
   ```

##### 4. 如何用正则实现 trim()？	

```js
  String.prototype.trim = function () {
    return this.replace(/^[\s\t]+/g, '');
  }
```

##### 5. 如何实现深拷贝？

```javascript
function deepClone(sources) {
  if (!sources || typeof sources !== 'object') {
    throw new Error('error arguments', 'shallowClone');
  }
  const target = Array.isArray(sources) ? []:{};
  for (const key in sources) {
    if (Object.hasOwnProperty.call(sources, key)) {
      if (sources[key] && typeof sources[key] === 'object') {
        target[key] = Array.isArray(sources[key]) ? []:{};
        target[key] = deepClone(sources[key]);
      } else {
        target[key] = sources[key];
      }
    }
  }
  return target;
}
```

##### 6. 不用 class 如何实现继承？

```javascript
if (!Object.create) {
  Object.create = function objectCreate(obj) {
     function ObjectCreate () {    }
    ObjectCreate.prototype = obj;
    return new ObjectCreate();
  }
}

function extend(subClass, superClass) {
  const obj = Object.create(superClass.prototype);
  subClass.prototype = obj;
  obj.constructor = subClass
}
```

##### 7. 手写一个 Promise

```javascript
if (!Promise) {
  const PENDING = Symbol("PENDING");
  const FULFILLED = Symbol("fulfilled");
  const REJECTED = Symbol("rejected");
  class Promise {
    constructor(executor) {
      this.data = null;
      this.onRejectedfns = [];
      this.onResolvefns = [];
      this.state = PENDING;

      const resolve = value => {
        if (value instanceof Promise) {
          return value.then(resolve, rejected);
        }
        setTimeout(() => {
          if (this.state === PENDING) {
            this.state = FULFILLED;
            this.data = value;
            this.onResolvefns.forEach(
              fn => fn && typeof fn === "function" && fn()
            );
          }
        });
      };

      const rejected = value => {
        if (value instanceof Promise) {
          return value.then(resolve, rejected);
        }
        setTimeout(() => {
          if (this.state === PENDING) {
            this.state = REJECTED;
            this.data = value;
            this.onRejectedfns.forEach(
              fn => fn && typeof fn === "function" && fn()
            );
          }
        });
      };

      try {
        executor(resolve, rejected);
      } catch (error) {
        rejected(err);
      }
    }
    then(onresolve, onrejected) {
      onresolve = typeof onresolve === "function" ? onresolve : value => value;
      onrejected =
        typeof onrejected === "function" ? onrejected : value => value;
      const self = this;
      if (this.state === FULFILLED) {
        return new Promise((resolve, rejected) => {
          setTimeout(() => {
            try {
              const data = onresolve(self.data);
              if (data instanceof Promise) {
                data.then(resolve, reject);
              }
              resolve(data);
            } catch (error) {
              rejected(err);
            }
          });
        });
      }
      if (this.state === REJECTED) {
        return new Promise((resolve, rejected) => {
          setTimeout(() => {
            try {
              const data = onrejected(self.data);
              if (data instanceof Promise) {
                data.then(resolve, reject);
              }
              resolve(data);
            } catch (error) {
              rejected(err);
            }
          });
        });
      }

      return new Promise((resolve, reject) => {
        self.onRejectedfns.push(value => {
          try {
            const data = onrejected(self.data);
            if (data instanceof Promise) {
              data.then(resolve, reject);
            }
            reject(data);
          } catch (error) {
            reject(data);
          }
        });
        self.onResolvefns.push(value => {
          try {
            const data = onresolve(self.data);
            if (data instanceof Promise) {
              data.then(resolve, reject);
            }
            resolve(data);
          } catch (error) {
            reject(data);
          }
        });
      });
    }
  }
}
```

### DOM部分

##### 1. 事件委托

##### 2. http状态码有哪些

200 OK 
请求正常处理完毕
204 No Content 
请求成功处理，没有实体的主体返回
206 Partial Content 
GET范围请求已成功处理
301 Moved Permanently 
永久重定向，资源已永久分配新URI
302 Found 
临时重定向，资源已临时分配新URI
303 See Other 
临时重定向，期望使用GET定向获取
304 Not Modified 
发送的附带条件请求未满足
307 Temporary Redirect 
临时重定向，POST不会变成GET
400 Bad Request 
请求报文语法错误或参数错误
401 Unauthorized 
需要通过HTTP认证，或认证失败
403 Forbidden 
请求资源被拒绝
404 Not Found 
无法找到请求资源（服务器无理由拒绝）
500 Internal Server Error 
服务器故障或Web应用故障
503 Service Unavailable 

服务器超负载或停机维护

##### 3. 深入理解浏览器的缓存机制

缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。

接下来的内容中我们将通过缓存位置、缓存策略以及实际场景应用缓存策略来探讨浏览器缓存机制。

![示意图](<https://upload-images.jianshu.io/upload_images/3174701-8e74b69ad9376710>)

###### 3.1. 缓存位置

​	从缓存位置上来说分为4种,并且各自有优先级,会按照相应的顺序去查询,当都没有命中时才回去请求网络.

+ Service Worker

+ Memory Cache

+ Disk Cache

+ Push Cache

  ###### Service Worker

  Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为Service Worker中涉及请求拦截,所以必须使用HTTPS协议来保障安全。**Service Worker 的缓存机制和其他浏览器内建的缓存方式不同,它可以允许我们自由的选择缓存哪些文件、如何匹配缓存、如何读取缓存、并且缓存是持续性的**。

  Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

  当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

  ###### Memory Cache

  Memory Cache也就是内存中的缓存，主要包含的是当前页面中已经抓取的资源，例如网页上已经下载的样式、脚本、图片等。读取内存中的速度肯定比磁盘中的快，虽然内存读取很高效，可是缓存持续性短，会随着进程的结束而释放。**一旦我们关闭Tap页面，内存中的缓存也将被释放**。

  **那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？**

  这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。

  当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。

  ![示意图](<https://upload-images.jianshu.io/upload_images/3174701-2fb1b19cf0d91709>)

  内存缓存中有一块重要的缓存资源是preloader相关指令（例如`<link rel="prefetch">`）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。

  需要注意的事情是，**内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验**。

  ###### Disk Cache

  Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，**比之 Memory Cache 胜在容量和存储时效性上**。

  在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。

  **浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？**
  关于这点，网上说法不一，不过以下观点比较靠得住：

  - 对于大文件来说，大概率是不存储在内存中的，反之优先
  - 当前系统内存使用率高的话，文件优先存储进硬盘
  
  ###### Push Cache
  
  Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。**它只会在session中存在，一旦会话结束就会被释放，并且缓存时间也很短**。在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。
  
  Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读`Jake Archibald`的 [HTTP/2 push is tougher than I thought](https://links.jianshu.com/go?to=https%3A%2F%2Fjakearchibald.com%2F2017%2Fh2-push-tougher-than-i-thought%2F) 这篇文章，文章中的几个结论：
  
  * 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差
  
  * 可以推送 no-cache 和 no-store 的资源
  
  * 一旦连接被关闭，Push Cache 就被释放
  
  * 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。
  
  * Push Cache 中的缓存只能被使用一次
  
  * 浏览器可以拒绝接受已经存在的资源推送
  
  * 你可以给其他域名推送资源
  
  如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。
  
  那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，**通常浏览器缓存策略分为两种，强缓存和协商缓存，并且缓存策略是通过设置HTTP Header来实现**。

###### 3.2 缓存过程分析

浏览器和服务器通信方式为应答模式，即浏览器发起HTTP请求——服务器响应请求，**那么浏览器如何确定一个资源该不该缓存，如何缓存**。浏览器第一次向服务器发起请求后拿到结果后，将请求结果和缓存标识存入浏览器缓存，**浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来决定的**。具体过程如下：

![示意图](<https://upload-images.jianshu.io/upload_images/3174701-de3d6e025582103a>)

由上图我们可以知道：

* 浏览器每次请求都会在浏览器缓存中查找请求缓存的结果和缓存标识
* 浏览器每次拿到返回的请求结果都会将结果和缓存标识存入浏览器缓存中。

以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。

###### 3.3 强缓存

**强缓存：不会向服务器发送请求，直接从缓存中读取资源，在Chrome的network中可以看到请求返回200的状态码，并且size显示from disk cache 或者 memory cache。强缓存可以通过设置HTTP Header实现：Expires和 Cache-Control**。

* Expires

  **缓存过期时间，用来指定资源到期时间，是服务器端的具体时间点**，也就是说Expires = max-age + 请求时间，需要和last-modified结合使用。Expires是Web服务器响应消息头字段，在响应时直接告诉浏览器在过期前可以直接从浏览器缓存中读取数据，无需再次请求。

  **Expires是HTTP/1的产物，受制于本地时间，使用如果修改了本地时间，可能造成缓存失效**。`Expires: Wed, 22 Oct 2018 08:41:00 GMT`表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。

* Cache-Control

  在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当`Cache-Control:max-age=300`时,则代表在这个这个请求正确返回时间5分钟内再次请求加载资源，就会命中强缓存。

  Cache-Control可以在请求头或者响应头中设置，并且可以组合使用多种指令。

  ![示意图](<https://upload-images.jianshu.io/upload_images/3174701-8ff981603cdfded0>)

  **public： 所有内容都将被缓存（客户端和代理服务器都可以）**。具体来说响应可以被任何中间节点缓存，如Browser <-- proxy1 <-- proxy2 <-- Server,中间的proxy都可以缓存资源，比如下次在请求同一资源的proxy1直接把自己的资源给浏览器而不用向proxy2要。

  **private： 所有的内容只有客户端可以缓存（Browser）**,Cache-Control的默认值，具体的说就是中间节点不允许缓存，如Browser <-- proxy1 <-- proxy2 <-- Server, proxy会老老实实的把Server返回的数据发送给proxy1，当然proxy1自己也不缓存数据，当下次browser再次请求的时候proxy会做好请求转发而不是自作主张的把自己的缓存的数据给browser。

  **no-cache**: 客户端缓存内容，是否需要缓存则需要通过协商缓存来决定。表示不使用Cache-Control的缓存控制方式前做前置验证，而是使用Etag或者Last-modified字段来控制缓存。**需要注意的是，no-cache这个名字存在一段误导，设置no-cache之后，并不是说浏览器就不再缓存数据了。只是浏览器缓存数据时，需要首先确认一下数据是不是还跟服务器保持一致。**

  **no-store**： 所有的内容都不会被缓存，即不用强制缓存，也不用协商缓存。

  **max-age**:   max-age=xxx（xxx  is numeric）表示缓存内容在xxx秒后失效。

  **s-maxage**（单位为s）：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即便更新了CDN内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires Header。

  **max-stale**：能容忍的最大到期时间。max-state指令标示了客户端愿意接受一个已经过期的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接受任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。

  **min-fresh**：能容忍的最小到期时间。min-fresh标示了客户端不愿接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。

  ![示意图](<https://upload-images.jianshu.io/upload_images/3174701-3fa81f5e9efac5af>)

从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。

###### 3.4 Expries 和 Cache-Control两者相比

其实两者相差不大，区别在于Expires是HTTP/1.0的产物，Cache-Control则是HTTP/1.1的产物。**两者同时存在的话，Cache-Control优先级高于Expires**；在某些不支持HTTP/1.1的环境下，Expries就会发挥作用。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。

强缓存判断是否缓存的依据来自于是否超出了某个时间或者某个时间段，而不关心服务器端文件是否更新，这可能会导致加载文件不是服务器最新的内容，**那我们如何获知服务器端内容是否发生了更新呢**？此时我们就需要用到协商缓存策略。

###### 3.5 协商缓存

**协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，有服务器根据缓存标识决定是否缓存的过程，主要有以下两种情况**：

* 协商缓存生效，返回304和Not Modified

  ![示意图](<https://upload-images.jianshu.io/upload_images/3174701-660fd163329d080b>)

* 协商缓存失效，返回200和求情结果

  ![示意图](<https://upload-images.jianshu.io/upload_images/3174701-24953079cfebf2bf>)

协商缓存可以通过设置两种HTTP header实现：Last-Modified 和 Etag。

1.  ###### Last-Modified 和If-Modified-Since

   浏览器在第一次访问资源的时候，服务器返回资源的同时，在response header中添加Last-Modified的header，这个值是服务器上最后的修改时间，浏览器在收后缓存文件和header。

   ```javascript
   Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
   ```

   浏览器在下一次请求这个资源，首先会检测到有Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值，当服务器再次收到这个资源请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间进行对比。如果没有变化，返回304和空的响应体，直接从缓存中读取，如果If-Modified-Since的值小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200状态码。

   ![示意图](<https://upload-images.jianshu.io/upload_images/3174701-bb7148a4431ccda1>)

   **但是Last-Modified存在一些弊端**：

   * 如果本地打开缓存文件，即便没有对缓存文件修改，但还是会造成Last-Modified被修改，服务端不能命中缓存导致发送相同的文件。
   * 因为Last-Modified只能以秒计时，如果存在秒以内的时间内修改文件，那么服务器会认为资源还是命中了，不会返回正确的资源。

   既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以HTTP/1.1出现了ETag 和 If-None-Match。

   **ETag 和 If-None-Match**

   ETag是服务器响应请求时，返回当前资源文件的一个唯一标识（有服务器生成），只要资源变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上次返回的Etag值放到request的header里的If-None-Match里面，服务器只需要比较客户端传过来的If-None-Match更自己服务器上该资源的Etag是否一致，就能很好的判断资源相对客户端而言是否修改过了。如果服务器上发现Etag匹配不上，那么直接以常规的GET 200回报形式将新的资源（当然也包括新的Etag码）发送给客户端。如果Etag一致，则直接返回304告知客户端直接使用本地缓存即可。

   ![示意图](<https://upload-images.jianshu.io/upload_images/3174701-2fd8f5306b4e6767>)

   **两者之间对比**

   * 首先在精确度上，Etag肯定由于Last-Modified。

     Last-Modified是以秒为时间单位，如果某个文件在一秒内改变多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度。如果是负载均衡的服务器，各个服务器生成的Last-Modified可能不一致。

   * 其次在性能上，Etag要逊色于Last-Modified，毕竟Last-Modified只要记录时间，而Etag需要服务器通过算法计算出一个hash值。
   * 最后在优先级上，服务器校验优先考虑Etag。

###### 3.6 缓存机制

**强制缓存优先于协商缓存进行，若强制缓存（Expires 和 Cache-Control）生效则直接使用缓存，若不生效则使用协商缓存（Last-Modified/If-Modified-Since 和 Etag/If-None-Match），协商缓存由服务器决定是否使用缓存，如果协商缓存失败，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存**。具体流程如下：

![示意图](<https://upload-images.jianshu.io/upload_images/3174701-9d9e8b52a18ed35a>)

**如果什么缓存策略都没有设置的话，浏览器会如何处理呢？**

对于这样的情况，浏览器会采用一个启发式的算法，通常会取响应头中的Date减去last-Modified值的10%来作为缓存时间。

###### 3.7 实际场景应用策略

* 频繁变动的资源

  ```javascript
  Cache-Control: no-cache
  ```

  对于频繁变动的资源，给它们设置Cache-Control: no-cache使浏览器每次都会请求服务器，然后配合Etag或者Last-Modified来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著的减少响应数据的大小。

* 不常变化的资源

  ``` javascript
  Cache-Control: max-age=31536000
  ```

  通常处理这类资源的时，给它们的Cache-Control配置一个很大<font color=red> `max-age=31536000`</font> （一年），这样浏览器之后请求相同的URL都会命中目标强制缓存。而为了解决更新问题，就需要在文件名（或者路径）中添加hash值，版本号等动态字符，之后更改动态字符，从而达到更改引用URL的目的，让之前的强制缓存失效（其实并没有立即失效，只是不再使用而已）。
  
  在线提供的类库 (如 `jquery-3.3.1.min.js`, `lodash.min.js` 等) 均采用这个模式。

###### 3.8 用户行为对浏览器缓存的影响

所谓的用户行为对浏览器缓存的影响指的就是用户在浏览器如何操作时会出发怎样的缓存策略。主要有3种:

* 打开网页，地址栏输入地址：查找disk cache 中是否有匹配。如果有则使用；如果没有则发送网络请求。
* 普通刷新（F5）：因为Tab并没有关闭，因此memory cache 并没有消失还是可用的（如果匹配的话）。其次才是disk cache。
* 如果是强制刷新（CTRL + F5）: 浏览器不会使用缓存，因此发送请求头均带有<font color="red">`cache-control: no-cache`</font>(为了兼容还带了<font color="red">`Pragma:no-cache`</font>)，服务器直接返回200状态码和最新的内容。

##### 4. GET 和 POST 的区别

* GET使用URL或Cookie传参，而POST可以将数据保存在BODY中。
* POST 比 GET 要安全（相对的安全）
* GET是幂等的，且可以缓存，POST费幂等、不可缓存。

##### 5.  Cookie V.S. Local Storage V.S. Session Storage

* **Cookie**

  cookie的定义：

  `An HTTP cookie (web cookie, browser cookie) is a small piece of data that a server sends to the user’s web browser. The browser may store it and send it back with the next request to the same server.` [MDN Doc](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies).

  翻译：cookie就是在浏览器端一个存储少量数据的空间。当然浏览器请求服务器时cookie就会随着HTTP request/response 来回传播。

  具体流程如下：

  ![示意图](<https://upload-images.jianshu.io/upload_images/3512785-071a6e9d51c076f0.png>)

  

  看起来很简单，但事实上cookie还有以下的特点

  1. 数据存储容量： 4KB左右。
  2. 可读取范围：浏览器任意窗口。
  3. 生命周期：客户端/服务器手动设置。不过一般有服务端生成，可以设置失效时间，如果有浏览器客服端生成则默认关闭浏览器后失效
  4. 存储位置： 服务器或者浏览器。
  5. 是否跟随HTTP res/req： Yes

  根据以上特点，cookie一般应用在登入验证、购物车内容、用户偏好和用户行为追踪等地方。

* **Session Storage** 

  Session Storage定义：

  The `sessionStorage` property allows you to access a session `Storage` object for the current origin. [MDN Doc](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage).

  Session Storage拥有的特性：

  1. 数据储存容量：5mb左右。
  2. 可读取的范围：同一个Tab标签。
  3. 生命周期：Tab关闭。
  4. 储存位置：浏览器端。
  5. 是否跟随HTTP res/req： No

  根据以上特点我们可以发现session storage在浏览器工作执行阶段，每一个tab都会开启一个新的session，而session storage正式这个阶段存放数据的地方。当然用户把这个tab关掉代表session结束，同时session storage里面的数据也会被清除。

* **Local Storage**

  The read-only `localStorage` property allows you to access a `Storage` object for the `Document`'s origin; the stored data is saved across browser sessions. [MDN Doc](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage).

  如同上面的文档介绍，Local Storage也是用来存放数据的，但是和session storage特性不太一样：

  1. 数据存储量： 10mb左右。
  2. 可读取范围：浏览器任意窗口。
  3. 生命周期： 除非用户清除否则不可能消失。
  4. 存储位置：浏览器。
  5. 是否跟随HTTP res/req： No

  比起session storage存储空间更大，除非被清除否则不可能消失。

### 框架 Vue

###### 1. watch 和 computed 和 methods 区别是什么？

* 从作用机制和性质上看待watch 和 computed 和 methods 区别关系。
* watch 和 method的比较。
* methods不处理数据逻辑关系，只提供可调用的函数
* 从功能的互补看待watch 和 computed 和 methods 的关系

**从作用机制和性质上看待methods,watch和computed的关系**

![示意图](https://pic3.zhimg.com/80/v2-f70b22e9abce971205ff000da8aac996_hd.jpg)

首先要说，watch 和 computed 、methods都是以函数为基础的，但各自却都不同。

**而从作用机制和性质上说，watch/computed和methods不太一样，接下来主要介绍两个对比：**

1. methods和（watch、computed）的对比
2. watch和computed的对比。

*从作用机制上：*

1.  watch和computed都是Vue的依赖追踪机智为基础的，它们都试图处理一件事情：当某个数据（称依赖数据）发生变化时，所有依赖这个数据的“相关”数据“自动”发生变化，也就是自动调用相关的函数去实现数据变动。
2. 对于methods里面的定义的函数，很显然，它们需要手动调用才能执行。而不像watch和computed那样，自动执行预先定义的函数。
3. computed在依赖数据初始化的时候就会执行，但是watch在watch对象初始化并不会执行。

【总结】：methods里面定义的函数，是需要主动调用的，而watch和computed相关的会自动的调用，完成我们希望完成的作用。

*从性质上看：*

1.  **methods**里面的定义是函数，因此我们需要像`name()`（假设函数为function name）。

2. **computed**是计算属性，事实上和data对象里面的数据是同一类型（使用上）。

   例如：

   ```js
   computed:{
      fullName: function () { return this.firstName + lastName }
   }
   ```

   在取用的时候，用`this.fullName`取用，就像data一样。

3. watch: 类似监听机制加上事件机制。

   例如：

   ```js
   watch: {
      firstName: function (val) {  this.fullName = val + this.lastName }
   }f
   ```

   firstName的改变时这个特殊事件被触发的条件，而firstName对应的函数就相当于监听到事件的发生后执行的方法。

   *watch和computed的对比*：

   如下图所示：

   ![示意图](https://pic1.zhimg.com/80/v2-7ed7710167ab764b99ff16b814441ee4_hd.jpg)

首先它们都是以Vue的依赖追踪机制为基础，它们的共同点是：在依赖数据发生改变的时候，被依赖的数据根据预先定义好的函数，发生“自动”的变化。

Vue为我们提供了一个方便的接口，统一规则。

**但是watch和computed也有不同的地方：**

* watch擅长处理的场景：一个数据影响多个数据

  ![示意图](https://pic2.zhimg.com/80/v2-44559dd39fda2e9b7dad2c6cf27a85b9_hd.jpg)

  我们用一个场景来描述：

  在《海贼王》里面，主角团队的名称叫做：“草帽海贼团”，所以我们把船员依次称为：草帽海贼团索隆、草帽海贼团娜美、以此类推。**我们希望：当船团名称发生变更的时候，这艘船上所有船员的名字一起变更！**

  代码如下：

  ```js
  var vm = new Vue({
    el: '#app',
    /*
     data选项中的数据：
     1.haiZeiTuan_Name --> 海贼团名称
     2.船员的名称 = 海贼团名称（草帽海贼团） + 船员名称（例如索隆）
   
     这些数据里存在这种关系：
     （多个）船员名称数据 --> 依赖于 --> （1个)海贼团名称数据
      一个数据变化 --->  多个数据全部变化
    */
    data: {
      haiZeiTuan_Name: '草帽海贼团',
      suoLong: '草帽海贼团索隆',
      naMei: '草帽海贼团娜美',
      xiangJiShi: '草帽海贼团香吉士'
    },
    /*
     在watch中，一旦haiZeiTuan_Name（海贼团名称）发生改变
     data选项中的船员名称全部会自动改变 （suoLong，naMei，xiangJiShi）
     并把它们打印出来
    */
    watch: {
      haiZeiTuan_Name: function (newName) {
        this.suoLong = newName + '索隆';
        this.naMei = newName + '娜美';
        this.xiangJiShi = newName + '香吉士';
        console.log(this.suoLong)
        console.log(this.naMei)
        console.log(this.xiangJiShi)
      }
    }
  })
   
  // 更改watch选项中监控的主数据
  vm.haiZeiTuan_Name = '橡胶海贼团'
  ```

  ![示意图](https://pic4.zhimg.com/80/v2-056586e2a113575ca65997dae4c546b3_hd.jpg)

  上图中的红色区域都发生了改变。如果我们又变了`vm.haiZeiTuan_Name = '肉肉海贼团'`:

  ![示意图](https://pic3.zhimg.com/80/v2-c9ca8ada7730d32359985efa7a97665a_hd.jpg)

* computed擅长处理的场景：一个数据被多个数据影响.

  ![示意图](https://pic2.zhimg.com/80/v2-52e31c31abfbf19863a2c33348875b65_hd.jpg)

  我们再用一个场景来描述：

  路飞的全名叫做：蒙奇-D-路飞，他想成为海贼王，但路飞的爷爷卡普（海军英雄）因此感到非常恼怒，于是把“路飞”改成了叫“海军王”，希望他能改变志向。

  代码如下：

  ```js
  var vm = new Vue({
    el: '#app',
    /*
     data选项中的数据：firstName，secName,thirdName
     computed监控的数据：lufei_Name
     两者关系： lufei_Name = firstName + secName + thirdName
     所以等式右边三个数据任一改变，都会直接修改 lufei_Name
    */
    data: {
      // 路飞的全名：蒙奇·D·路飞
      firstName: '蒙奇',
      secName: 'D',
      thirdName: '路飞'
    },
    computed: {
      luFei_Name: function () {
        return this.firstName + this.secName + this.thirdName
      }
    }
  })
   
  // 将“路飞”改为“海军王”
  vm.thirdName = '海军王'
  // 打印路飞的全名 console.log(vm.luFei_Name)
  ```

  ![示意图](https://pic1.zhimg.com/80/v2-ae61c4455b5c4ff1547b374413427810_hd.jpg)

  但是，突然我们又改了名字`vm.secName = 'H'`;

  ![示意图](https://pic4.zhimg.com/80/v2-178cfe0ece4efd216a8920dc3a21b59f_hd.jpg)

  

  相对于watch/computed，methods不处理数据逻辑关系，只提供调用的函数

  ```js
  new Vue({
    el: '#app',
    template: '<div id="app"><p>{{ say() }}</p></div>',
    methods: {
      say: function () {
        return '我要成为海贼王'
      }
    }
  })
  ```

  ![示意图](https://pic2.zhimg.com/80/v2-758bc37517b0ab3e7d1a2de0fc8b431d_hd.jpg)

  *从功能互补上看待methods，watch/computed的关系*

  ![示意图](https://pic2.zhimg.com/80/v2-d27bd075a02fcfd1f17b2c44a10a56a5_hd.jpg)

  在很多时候，computed是用来处理你使用watch和methods的时候无法处理，或者是处理起来并不太恰当的情况的。

  *利用computed处理methods存在的重复计算情况*

  ![示意图](https://pic2.zhimg.com/80/v2-bc4ebd4a38a71f8e0af6c524a58e3891_hd.jpg)

  1. methods里面的函数就是一群“**耿直Boy**”，如果有其他父函数调用它，它会每一次都“乖乖”地执行并返回结果，即使这些结果很可能是相同的，是不需要的

  2. 而computed是一个“**心机Boy**”，它会以Vue提供的依赖追踪系统为基础，只要依赖数据没有发生变化,computed就不会再度进行计算。

     代码如下：

     ```js
     new Vue({
       el: '#app',
       // 设置两个button，点击分别调用getMethodsDate,getComputedDate方法
       template: '<div id="app"><button @click="getMethodsDate">methods</button><button @click="getComputedDate">computed</button></div>',
       methods: {
         getMethodsDate: function () {
           alert(new Date())
         },
         // 返回computed选项中设置的计算属性——computedDate
         getComputedDate: function () {
           alert(this.computedDate)
         }
       },
       computed: {
         computedDate: function () {
           return new Date()
         }
       }
     ```

     当我们第一次点击methods按钮：

     ![示意图](https://pic2.zhimg.com/80/v2-a247ee53f075eeadd60796864d4cd3ad_hd.jpg)

     第二次点击methods按钮：

     ![示意图](https://pic1.zhimg.com/80/v2-e1151fc9fbdb98185d9bc004ac0ddaac_hd.jpg)

     **我们可以发现2次点击methods返回的`new Date()`是不一样的**。

     当我们第一次点击computed按钮：

     ![示意图](https://pic3.zhimg.com/80/v2-f878cc659541e6ceed96e96d30c11a3e_hd.jpg)

     第二次点击computed按钮：

     ![示意图](https://pic3.zhimg.com/80/v2-f878cc659541e6ceed96e96d30c11a3e_hd.jpg)

     

     **注意两次点击返回的时间是相同的！**

     *为什么两次点击methods返回的时间不同而computed返回相同？因为`new Date()`不是依赖数据（不是放在data对象下的实例数据），所以computed只提供了缓存，并没有重复计算。*

     **因此只有符合条件**：

     1. 存在依赖数据
     2. 依赖数据改变。

     满足这两个条件，computed还会重新计算。因此我们可以利用*computed处理watch在特定情况下代码冗余的现象。*

     ![示意图](https://pic4.zhimg.com/80/v2-8bc9c444b6e467ac4eb717801169506b_hd.jpg)

     ```js
     new Vue({
       el: '#app',
       data: {
         fullName: '吴彦祖',
         firstName: '吴',
         secName: '彦',
         thirdName: '祖'
       },
       // watch中的代码显然是同类型，重复的，它并不简洁，也不优雅   watch: {
         firstName: function (newValue) {
           this.fullName = newValue + this.secName + this.thirdName
           console.log(this.fullName)
         },
         secName: function (newValue) {
           this.fullName = this.firstName + newValue + this.thirdName
           console.log(this.fullName)
         },
         thirdName: function (newValue) {
           this.fullName = this.firstName + this.secName + newValue
           console.log(this.fullName)
         }
       }
     })
     ```

     watch中的代码显然是同类型，重复的，它并不简洁，也不优雅，所以我们可以把它变成这样：

     ```js
     new Vue({
       el: '#app',
       data: {
         fullName: '彭湖湾',
         firstName: '彭',
         secName: '湖',
         thirdName: '湾'
       },
       // 对watch中的代码进行重构，实现同样效果
       computed: function () {
         this.fullName = this.firstName + this.secName + this.thirdName
         console.log(this.fullName)
       }
     })
     ```

     

###### 2.  Vue 有哪些生命周期钩子函数？

在我们平时使用Vue的时候都免不了用到一种特性，就是生命周期函数，这些钩子可以提供给我们很多便利，让我们在数据更新的每个阶段都可以捕捉到它的变化。

先来一份大纲：

* **beforeCreate（初始化界面前）**
* **created（初始化界面后）**
* **beforeMount（渲染DOM前）**
* **mounted（渲染DOM后）**
* **beforeUpdate（更新数据前）**
* **updated（更新数据后）**
* **beforeDestroy（卸载组件前）**
* **destroy（卸载组件后）**

现在我们就来分析一下，`Vue`在调用到每个生命周期前都做了什么？

**首先，我们来看看官方的生命周期流程图：**

![示意图](https://user-gold-cdn.xitu.io/2019/2/20/1690b0a7158c1cbd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这张图其实已经大概的告诉了我们，每个阶段做了什么，但是我觉得还有必要详细的去分析一下，这样在未来如果我们要实现类似于 `vue` 这种框架的时候，可以知道在什么时间，应该去做什么，怎么去实现。

1. **beforeCreate（初始化界面前）**

   ```javascript
   function initInternalComponent (vm, options) {
     var opts = vm.$options = Object.create(vm.constructor.options);
     // doing this because it's faster than dynamic enumeration.
     var parentVnode = options._parentVnode;
     opts.parent = options.parent;
     opts._parentVnode = parentVnode;
     opts._parentElm = options._parentElm;
     opts._refElm = options._refElm;
   
     var vnodeComponentOptions = parentVnode.componentOptions;
     opts.propsData = vnodeComponentOptions.propsData;
     opts._parentListeners = vnodeComponentOptions.listeners;
     opts._renderChildren = vnodeComponentOptions.children;
     opts._componentTag = vnodeComponentOptions.tag;
   
     if (options.render) {
       opts.render = options.render;
       opts.staticRenderFns = options.staticRenderFns;
     }
   }
   function resolveConstructorOptions (Ctor) {
     var options = Ctor.options;
     if (Ctor.super) {
       var superOptions = resolveConstructorOptions(Ctor.super);
       var cachedSuperOptions = Ctor.superOptions;
       if (superOptions !== cachedSuperOptions) {
         // super 选项已更改，需要解决新选项。
         Ctor.superOptions = superOptions;
         // 检查是否有任何后期修改/附加选项
         var modifiedOptions = resolveModifiedOptions(Ctor);
         // 更新基本扩展选项
         if (modifiedOptions) {
           extend(Ctor.extendOptions, modifiedOptions);
         }
         options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
         if (options.name) {
           options.components[options.name] = Ctor;
         }
       }
     }
     return options
   }
   if (options && options._isComponent) {
     initInternalComponent(vm, options);
   } else {
     vm.$options = mergeOptions(
       resolveConstructorOptions(vm.constructor),
       options || {},
       vm
     );
   }
   
   if (process.env.NODE_ENV !== 'production') {
     initProxy(vm);
   } else {
     vm._renderProxy = vm;
   }
   
   vm._self = vm;
   initLifecycle(vm);
   initEvents(vm);
   initRender(vm);
   callHook(vm, 'beforeCreate');
   
   ```

   在一开始。先做一个属性的合并处理，如果`options`存在并且`_isComponet`为`true`，那么久调用`initInternalComponent`方法，这个方法最主要是内部组件实例化，因为动态选项合并非常慢，并且没有内部组件选项需要特殊处理。

   如果不满足以上条件，就调用`mergeOptions`方法去做属性合并，最后的返回值赋值给`$options`。

   然后在做一个渲染拦截，主要是为了在调用`render`方法的时候，通过`vm.$createElement`方法进行DOM创建。

   ```javascript
   function initLifecycle (vm) {
     var options = vm.$options;
   
     // 找到第一个非抽象父级
     var parent = options.parent;
     if (parent && !options.abstract) {
       while (parent.$options.abstract && parent.$parent) {
         parent = parent.$parent;
       }
       parent.$children.push(vm);
     }
   
     vm.$parent = parent;
     vm.$root = parent ? parent.$root : vm;
   
     vm.$children = [];
     vm.$refs = {};
   
     vm._watcher = null;
     vm._inactive = null;
     vm._directInactive = false;
     vm._isMounted = false;
     vm._isDestroyed = false;
     vm._isBeingDestroyed = false;
   }
   ```

   初始化了一些参数：

   ```javascript
   function initEvents (vm) {
     vm._events = Object.create(null);
     vm._hasHookEvent = false;
     // init父级附加事件
     var listeners = vm.$options._parentListeners;
     if (listeners) {
       updateComponentListeners(vm, listeners);
     }
   }
   function updateComponentListeners (
     vm,
     listeners,
     oldListeners
   ) {
     target = vm;
     updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
     target = undefined;
   }
   ```

   初始化事件，如果`_parentListeners`存在的话，更新组件的事件监听

   ```javascript
   function initRender (vm) {
     vm._vnode = null; // 子树的根
     vm._staticTrees = null; // v-once缓存的树
     var options = vm.$options;
     var parentVnode = vm.$vnode = options._parentVnode; // 父树中的占位符节点
     var renderContext = parentVnode && parentVnode.context;
     vm.$slots = resolveSlots(options._renderChildren, renderContext);
     vm.$scopedSlots = emptyObject;
     // 将createElement fn绑定到此实例，以便我们在其中获得适当的渲染上下文。
     vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
     // 规范化始终应用于公共版本，在用户编写的渲染函数中使用。
     vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
   
     // 暴露了$ attrs和$ listeners以便更容易创建HOC。
     // 他们需要被动反应，以便使用它们的HOC始终更新
     var parentData = parentVnode && parentVnode.data;
   
     /* istanbul ignore else */
     if (process.env.NODE_ENV !== 'production') {
       defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
         !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
       }, true);
       defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
         !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
       }, true);
     } else {
       defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
       defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
     }
   }
   ```

   到了这里执行完毕后，就调用到了 `beforeCreate` 方法。

2. **created(初始化界面后)**

      ```js
   initInjections(vm); // 在数据/道具之前解决注入
   initState(vm);
   initProvide(vm); // 解决后提供的数据/道具
   callHook(vm, 'created');
   ```

   ```javascript
   function resolveInject (inject, vm) {
     if (inject) {
       // 因为流量不足以弄清楚缓存
       var result = Object.create(null);
       var keys = hasSymbol
         ? Reflect.ownKeys(inject).filter(function (key) {
           return Object.getOwnPropertyDescriptor(inject, key).enumerable
         })
         : Object.keys(inject);
   
       for (var i = 0; i < keys.length; i++) {
         var key = keys[i];
         var provideKey = inject[key].from;
         var source = vm;
         while (source) {
           if (source._provided && hasOwn(source._provided, provideKey)) {
             result[key] = source._provided[provideKey];
             break
           }
           source = source.$parent;
         }
         if (!source) {
           if ('default' in inject[key]) {
             var provideDefault = inject[key].default;
             result[key] = typeof provideDefault === 'function'
               ? provideDefault.call(vm)
               : provideDefault;
           } else if (process.env.NODE_ENV !== 'production') {
             warn(("Injection \"" + key + "\" not found"), vm);
           }
         }
       }
       return result
     }
   }
   var shouldObserve = true;
   
   function toggleObserving (value) {
     shouldObserve = value;
   }
   function initInjections (vm) {
     var result = resolveInject(vm.$options.inject, vm);
     if (result) {
       toggleObserving(false);
       Object.keys(result).forEach(function (key) {
         if (process.env.NODE_ENV !== 'production') {
           defineReactive(vm, key, result[key], function () {
             warn(
               "Avoid mutating an injected value directly since the changes will be " +
               "overwritten whenever the provided component re-renders. " +
               "injection being mutated: \"" + key + "\"",
               vm
             );
           });
         } else {
           defineReactive(vm, key, result[key]);
         }
       });
       toggleObserving(true);
     }
   }
   ```

   在这里，其实最主要就是用来做不需要响应式的数据，官方文档：[provide / inject](https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23provide-inject) ；

   ```javascript
   function initState (vm) {
     vm._watchers = [];
     var opts = vm.$options;
     if (opts.props) { initProps(vm, opts.props); }
     if (opts.methods) { initMethods(vm, opts.methods); }
     if (opts.data) {
       initData(vm);
     } else {
       observe(vm._data = {}, true /* asRootData */);
     }
     if (opts.computed) { initComputed(vm, opts.computed); }
     if (opts.watch && opts.watch !== nativeWatch) {
       initWatch(vm, opts.watch);
     }
   }
   ```

   在处理完 `inject` 后，紧接着就做了 `props` 、`methods` 、`data` 、`computed` 和 `watch` 的初始化处理；

   ```javascript
   function initProvide (vm) {
     var provide = vm.$options.provide;
     if (provide) {
       vm._provided = typeof provide === 'function'
         ? provide.call(vm)
         : provide;
     }
   }
   ```

   `Provide` 和 `Inject` 作用其实是一样的，只是处理的方式不一样，具体区别请看官方文档：[provide / inject](https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23provide-inject) ；

   到这里执行完毕后，就要走到 `created` 钩子了。

3. **beforeMount(渲染DOM前)**

   ```javascript
   if (vm.$options.el) {
     vm.$mount(vm.$options.el);
   }
   ```

   在渲染 `dom` ，先检查了是否存在渲染位置，如果不存在的话，也就不会注册了；

   ```javascript
   Vue.prototype.$mount = function (
     el,
     hydrating
   ) {
     el = el && inBrowser ? query(el) : undefined;
     return mountComponent(this, el, hydrating)
   };
   function mountComponent (
     vm,
     el,
     hydrating
   ) {
     vm.$el = el;
     if (!vm.$options.render) {
       vm.$options.render = createEmptyVNode;
     }
     callHook(vm, 'beforeMount');
   }
   ```

   在 `beforeMount` 这里，基本没做什么事情，只是做了一个 `render` 方法如果存在就绑定一下 `createEmptyVNode` 函数；

   绑定完毕后，就执行了 `beforeMount` 钩子；

4. **mounted(渲染DOM后)**

   ```javascript
     var updateComponent;
     if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
       updateComponent = function () {
         var name = vm._name;
         var id = vm._uid;
         var startTag = "vue-perf-start:" + id;
         var endTag = "vue-perf-end:" + id;
   
         mark(startTag);
         var vnode = vm._render();
         mark(endTag);
         measure(("vue " + name + " render"), startTag, endTag);
   
         mark(startTag);
         vm._update(vnode, hydrating);
         mark(endTag);
         measure(("vue " + name + " patch"), startTag, endTag);
       };
     } else {
       updateComponent = function () {
         vm._update(vm._render(), hydrating);
       };
     }
   
     // 我们在观察者的构造函数中将其设置为vm._watcher，因为观察者的初始补丁可能会调用$ forceUpdate（例如，在子组件的挂载挂钩内），这依赖于已定义的vm._watcher
     new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
     hydrating = false;
   
     // 手动挂载的实例，在自己挂载的调用挂载在其插入的挂钩中为渲染创建的子组件调用
     if (vm.$vnode == null) {
       vm._isMounted = true;
       callHook(vm, 'mounted');
     }
   
   ```

   在 `new Watcher` 的时候，调用了 `_render` 方法，实现了 `dom` 的渲染

   在执行完实例化 `Watcher` 以后，如果 `$node` 不存在，就说明是初始化渲染，执行 `mounted` 钩子；

5. **beforeUpdate(更新渲染前）**

   ```javascript
   Vue.prototype._update = function (vnode, hydrating) {
       var vm = this;
       if (vm._isMounted) {
         callHook(vm, 'beforeUpdate');
       }
   
   };
   ```

   如果当前的 `vue` 实例的 `_isMounted` 为 `true` 的话，直接调用 `beforeUpdate` 钩子；

   `_isMounted `在 `mounted` 钩子执行前就已经设置为 true 了。

   执行 `beforeUpdate` 钩子；

6. **updated(更新渲染后)**

   ```javascript
   function callUpdatedHooks (queue) {
     var i = queue.length;
     while (i--) {
       var watcher = queue[i];
       var vm = watcher.vm;
       if (vm._watcher === watcher && vm._isMounted) {
         callHook(vm, 'updated');
       }
     }
   }
   ```

   因为有多个组件的时候，会有很多个 `watcher` ，在这里，就是检查当前的得 `watcher` 是哪个，是当前的话，就直接执行当前 `updated` 钩子。

7. **beforeDestroy(组件卸载前）**

   ```javascript
   Vue.prototype.$destroy = function () {
       var vm = this;
       if (vm._isBeingDestroyed) {
         return
       }
       callHook(vm, 'beforeDestroy');
   };
   ```

   在卸载前，检查是否已经被卸载，如果已经被卸载，就直接 `return` 出去；

   执行 `beforeDestroy` 钩子；

8. **Destroyed(组件卸载前）**

   ```javascript
   vm._isBeingDestroyed = true;
   // 从父级那里删除自己
   var parent = vm.$parent;
   if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
     remove(parent.$children, vm);
   }
   // 拆解观察者
   if (vm._watcher) {
     vm._watcher.teardown();
   }
   var i = vm._watchers.length;
   while (i--) {
     vm._watchers[i].teardown();
   }
   // 从冻结对象的数据中删除引用可能没有观察者。
   if (vm._data.__ob__) {
     vm._data.__ob__.vmCount--;
   }
   // 准备执行最后一个钩子
   vm._isDestroyed = true;
   // 在当前渲染的树上调用destroyed hook
   vm.__patch__(vm._vnode, null);
   
   callHook(vm, 'destroyed');
   
   ```

   其实这里就是把所有有关自己痕迹的地方，都给删除掉；

   执行 `destroyed` 钩子。

**总结：**

到这里，其实每一个生命周期的钩子做了什么，我们已经了解的差不多了，那这样大量的代码看起来可能不是很方便，所以我们做一个总结的 `list`：

`beforeCreate` ：初始化了部分参数，如果有相同的参数，做了参数合并，执行 `beforeCreate` ；

`created` ：初始化了 `Inject` 、`Provide` 、 `props` 、`methods` 、`data` 、`computed` 和 `watch`，执行 `created` ；

`beforeMount` ：检查是否存在 `el` 属性，存在的话进行渲染 `dom` 操作，执行 `beforeMount` ；

`mounted` ：实例化 `Watcher` ，渲染 `dom`，执行 `mounted` ；

`beforeUpdate` ：在渲染 `dom` 后，执行了 `mounted` 钩子后，在数据更新的时候，执行 `beforeUpdate` ；

`updated` ：检查当前的 `watcher` 列表中，是否存在当前要更新数据的 `watcher` ，如果存在就执行 `updated` ；

`beforeDestroy` ：检查是否已经被卸载，如果已经被卸载，就直接 `return` 出去，否则执行 `beforeDestroy` ；

`destroyed` ：把所有有关自己痕迹的地方，都给删除掉；

###### 3. Vue 如何实现组件间通信？

1.  **父组件-->子组件**

   父组件代码：

   ```javascript
   <child-page :child-msg="data"></child-page>
   ```

   子组件代码:

   ```javascript
   export default {
     name: 'child',
     props: {
       child-msg: String
     }
   };
   ```

   或者`this.$children` 访问它所有的子组件， 而且可以递归向下无限访问，

2. **子组件-->父组件**

   *发送事件/监听事件*

   子组件中某函数内发送事件：

   ```javascript
   this.$emit('toparentevent', 'data');
   ```

   父组件监听事件：

   ```javascript
   <Child :msg="msg" @toparentevent="todo()"></Child>
   ```

   或者使用 `this.$parent` 可以直接访问该组件的父实例或组件，而且可以递归向上访问。

3.  **父组件直接获取子组件属性或方法**

   给要调用的子组件起个名字。将名字设置为子组件 ref 属性的值。
   <!-- 子组件。 ref的值是组件引用的名称 -->

   ```js
   <child-component ref="aName"></child-component>
   ```

   父组件中通过 $refs.组件名 来获得子组件，也就可以调用子组件的属性和方法了。

   ```javascript
   var child = this.$refs.aName
   child.属性
   child.方法()
   ```

   **最重要的方式：vue组件通信，中央控制总线**

   ![示意图](https://segmentfault.com/img/bVbeqb5?w=812&h=700)

   实现不同组价之间的通信，其实很简单，请看下面步骤：

   1.  新建control.js

      ```javascript
      import Vue from 'vue'
      export default new Vue()
      ```

   2. 在需要发射或者监听的界面引入，并使用。

      这就是一个中央事件总线，然后我们在需要发送或者监听事件的界面引入这个文件，然后使用里面的`$on/$emit`来监听和发射消息即可。

      ```javascript
      import control from './control.js'
      // 监听
      created () {
      control.$on('需要监听的事件名称', ()=> {
          // 需要执行的命令
      }
      
      // 发射时间
      methods () {
          emitFun() {
              control.$emit("childEmitFun", "参数");
          }
      }
      ```

   3. 实例

      * 目录, 界面

        ![示意图](https://segmentfault.com/img/bVbep56?w=168&h=111)

        ![示意图](https://segmentfault.com/img/bVbep6N?w=658&h=408)

        都引入到`app.vue`中

        ![示意图](https://segmentfault.com/img/bVbep6i?w=608&h=388)

      * B: ParentOne.vue

        ```javascript
        <template>
            <div>
                <br/>
                <br/>
                <v-button @click="emitOneFun()" type="primary">发送给兄弟组件</v-button>
            </div>
        </template>
        <script>
        import center from '../center/center.js'
        export default {
            name: "parentOne",
            created() {
                
            },
            methods: {
                emitOneFun() {
                    center.$emit("emitParentOne");
                }
            }
        }
        </script>
        ```

      * C: parentTwo.vue

        ```javascript
        <template>
        <div>
            <br/>
            <br/>
            <v-button @click="emitChildrenOneFun" type="primary">发送消息到子组件</v-button>
        </div>
        </template>
        <script>
            import center from "../center/center.js"
            export default {
                mounted () {
                    center.$on("emitParentOne", ()=> {
                        alert("接收兄弟组件传递过来的信息");
                    })
                },
                methods: {
                    emitChildrenOneFun() {
                        center.$emit("emitChildrenOne");
                    }
                }
            }
        </script>
        ```

      * D: ChildrenOne.vue

        ```javascript
        <script>
            import center from "../../center/center.js"
            export default {
                mounted () {
                    center.$on("emitChildrenOne", ()=> {
                        alert("监听发送childrenOne的事件")
                    })
                }
            }
        </script>
        ```

###### 4. Vue 路由守卫

主要梳理一下几个方面：

1. 路由守卫的执行顺序是怎么样的？
2. 路由守卫中的next的用处？
3. 为什么afterEach守卫没有next？
4. beforeEach是否可以叠加？
5. 路由跳转经历了哪几部分？

在这之前先说一个router实例的history属性帮助我们做了所有路由跳转部分的事情，所以路由守卫也在html5的history中。

![示意图](https://user-gold-cdn.xitu.io/2018/9/28/1661e1b2832bb3fb?w=263&h=99&f=png&s=6748)

先来History这个类中的push方法：

```javascript
push (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    const { current: fromRoute } = this
    this.transitionTo(location, route => {
      pushState(cleanPath(this.base + route.fullPath))
      handleScroll(this.router, route, fromRoute, false)
      onComplete && onComplete(route)
    }, onAbort)
  }
```

push（我们跳转时的$router.push就是这个方法）过程中调用了`transitionTo`完成了一系列的跳转内容，但这个方法在HTML5的类中并不存在，继承于base.js类中的方法

`transitionTo`才是实现路由跳转的方法。

`transitionTo`主要的流程由`confirmTranstion`跟`uodateRoute`方法结合起来的，翻译成普通话：路由跳转要先经过一个确认跳转的过程，在确认过程完成后进行一次路由的更新操作:

```javascript
transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    // 获取要跳转的并且经过处理的路由
    const route = this.router.match(location, this.current)
    // confirmTranstion确认跳转过程
    this.confirmTransition(route, () => {
      // 确认完毕后完成更新路由操作
      this.updateRoute(route)
      onComplete && onComplete(route)
      this.ensureURL()

      // fire ready cbs once
      if (!this.ready) {
        this.ready = true
        this.readyCbs.forEach(cb => { cb(route) })
      }
    }, err => {
      if (onAbort) {
        onAbort(err)
      }
      if (err && !this.ready) {
        this.ready = true
        this.readyErrorCbs.forEach(cb => { cb(err) })
      }
    })
  }
```

`confirmTransiton`做了什么呢？首先判断一下你是不是相同的路由。如果是那就什么都不做，第二步呢，我们要开始收集一波守卫了，然后把守卫收集起来，然后把每个守卫执行一遍，`confirmTransiton`就算执行成功了。

![示意图](https://user-gold-cdn.xitu.io/2018/9/28/1661e2c04e9aea0c?w=985&h=787&f=png&s=160684)

*这个过程中的难点是什么？*

* 如何收集守卫组成守卫队列
* 如何按照顺序执行守卫的同时可以随时中中止守卫队列
* 如何找到守卫队列执行完毕后的那个节点

在vue-router中封装了一个runQueue函数来解决上面的三个问题的后两个。第一个问题呢则涉及到vue-router处理路由的一个大篇章，我们着重讲一下runQueue函数

*runQueue函数的思路*：

1.  迭代器模式来保证队列每一步都是可控
2. 队列执行完后执行响应的回调函数

```javascript
export function runQueue (queue: Array<?NavigationGuard>, fn: Function, cb: Function) {
  const step = index => {
  // 队列里已经没有内容可以执行了，那就代表队列执行完成了
    if (index >= queue.length) {
      cb()
    } else {
      // 如果队列内容存在就执行迭代函数
      if (queue[index]) {
        fn(queue[index], () => {
          step(index + 1)
        })
      // 什么也没有那就到下一步了        
      } else {
        step(index + 1)
      }
    }
  }
  // 启动了
  step(0)
}
```

`runQueue`帮我们解决了守卫队列处理的问题。那剩下的是如何收集守卫，还有我们想要那些守卫？

**守卫分为两种类型：前置守卫、后置守卫**

* 前置守卫：
  1. 全局的前置守卫：beforeEach、beforeResolve
  2. 路由独享守卫： beforeEnter
  3. 组件内守卫：beforeRouterEnter、beforeRouterUpdate、beforeRouterLeave

* 后置守卫：

  全局的前置守卫：afterEach

现在想一下这些守卫都是怎么注册的：

* 在路有实例注册的：

  beforeEach、beforeResolve、afterEach

* 在路由配置中注册的（路由独享守卫）:

  beforeEnter

* 组件内的路由守卫：

  beforeRouteLeave、beforeRouteUpdate、beforeRouteEnter

`confirmTransition`的守卫分为两个队列：我们先来看第一个队列

```javascript
 // 拿到路由跳转中更新、摧毁、激活时对应展示的组件。
 const {
      updated,
      deactivated,
      activated
    } = resolveQueue(this.current.matched, route.matched)
    // 路由守卫
    const queue: Array<?NavigationGuard> = [].concat(
      // in-component leave guards
      extractLeaveGuards(deactivated),
      // global before hooks
      this.router.beforeHooks,
      // in-component update hooks
      extractUpdateHooks(updated),
      // in-config enter guards
      activated.map(m => m.beforeEnter),
      // async components
      resolveAsyncComponents(activated)
    )
```

一个queue的顺序：

1. 拿到被摧毁的组件的，榨取出所有组件内的离开守卫。
2. 全局的beforeEach组件。
3. 拿到更新的所有组件，榨取出所有组件内的更新守卫。
4. 遍历要进入的路由，拿到所有路由的独享守卫。
5. 加载要被激活的异步组件

7个守卫中的4个守卫都在被按顺序拿出来了，放入第一个queue。

再下一步要有一个处理守卫的迭代器。

**我们如何处理守卫？**

1. 保证在守卫中可以停止并且跳转到其余路由，
2. 保证守卫可以正常通过，

```javascript
const iterator = (hook: NavigationGuard, next) => {
      if (this.pending !== route) {
        return abort()
      }
      try {
        hook(route, current, (to: any) => {
          // 传个false就直接执行路由的错误处理，然后停止什么都不做。
          if (to === false || isError(to)) {
            // next(false) -> abort navigation, ensure current URL
            this.ensureURL(true)
            abort(to)
          } else if (
          // 如果我们接受了一个可以操作的路径。
            typeof to === 'string' ||
            (typeof to === 'object' && (
              typeof to.path === 'string' ||
              typeof to.name === 'string'
            ))
          ) {
            // next('/') or next({ path: '/' }) -> redirect
            abort()
            // 我们就执行路由跳转操作，并且守卫队列停止下面的迭代
            if (typeof to === 'object' && to.replace) {
              this.replace(to)
            } else {
              this.push(to)
            }
          } else {
            // confirm transition and pass on the value
            // 接续迭代下去咯
            next(to)
          }
        })
      } catch (e) {
        abort(e)
      }
    }
```

next函数，之前在将runQueue的函数的时候，fn接收第二个参数（之前画过重点），第二个参数的回调函数是完成迭代器向下一步执行的功能。

所有的前置守卫都接收三个参数：

```
runQueue(queue, iterator, () => {
      const postEnterCbs = []
      const isValid = () => this.current === route
      // wait until async components are resolved before
      // extracting in-component enter guards
      const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)
      const queue = enterGuards.concat(this.router.resolveHooks)
      runQueue(queue, iterator, () => {
        if (this.pending !== route) {
          return abort()
        }
        this.pending = null
        onComplete(route)
        if (this.router.app) {
          this.router.app.$nextTick(() => {
            postEnterCbs.forEach(cb => { cb() })
          })
        }
      })
    })
```

我们在把第一个queue（四个守卫与一个异步组件的加载）执行完毕后，要收集与执行第二个queue了，

第二个queue：

1. 收集了被的激活组件内的进入守卫
2. 全局的beforeResolve的守卫

收集完开始执行第二个queue的迭代。第二个queue执行完执行一下onComplete函数，代表着confirmTransition方法执行完毕了。确认路由的过程结束了，

下面就是`updateRoute`的过程。`updateRoute`的时候执行全部的后置守卫，因为更新路由之后，当前的路由已经变化了，所以在给守卫传参数的时候缓存了一下，之前的路由。

```javascript
updateRoute (route: Route) {
    const prev = this.current
    this.current = route
    this.cb && this.cb(route)
    this.router.afterHooks.forEach(hook => {
      hook && hook(route, prev)
    })
  }
```

所以为什么afterEach没有next呢？因为afterEach根本不在迭代器之内，他就没有next来触发迭代器的下一步。

最后我们说一下beforeEach的内容：
我们设置beforeEach全局守卫的时候，守卫们存储在哪里？

```javascript
beforeEach (fn: Function): Function {
    return registerHook(this.beforeHooks, fn)
}
function registerHook (list: Array<any>, fn: Function): Function {
  list.push(fn)
  // 返回值是一个function
  return () => {
    const i = list.indexOf(fn)
    if (i > -1) list.splice(i, 1)
  }
}
```

这段代码beforeEach是通过注册守卫的方式，将注册的全局前置守卫放在beforeHooks的容器内，这个容器里面装载着所有的前置守卫。

![示意图](https://user-gold-cdn.xitu.io/2018/9/28/1661f0d037728a31?w=600&h=65&f=png&s=10982)

一家人（全局的 前置进入、前置resolve、后置守卫）整整齐齐的放在对应的容器里面，容器是个数组，所以注册全局守卫的时候，是支持注册多个的，

```javascript
router.beforeEach(()=>{xxx});
router.beforeEach(()=>{yyy});
// 这两个守卫都会执行，只是先注册的先执行，
// registerHook这个方法还可以清除对应的守卫，这个方法也可以使用
```

**总结**

我们来回答一下开篇的5个问题

1.  *导航守卫的执行顺序是怎么样的？*

   beforeRouteLeave < beforeEach < beforeRouteUpdate < beforeEnter < beforeRouteEnter < beforeResolve < afterEach

2. 导航守卫中的next的用处？

   next的作用，使导航守卫队列的继续向下迭代.

3. 为什么afterEach守卫没有next？

   afterEach根本不在导航守卫队列内，没有迭代的next

4. beforeEach是否可以叠加？

   beforeEach是可以叠加的，所有的全局前置守卫按顺序存放在beforeHooks的数组里面，

5. 路由跳转经历了哪几部分？

   路由跳转的核心方法是transitionTo，在跳转过程中经历了一次confirmTransition，

   （beforeRouteLeave < beforeEach < beforeRouteUpdate < beforeEnter < 异步组件加载）这样顺序的queue为第一个，

   在第一个queue迭代完毕后，执行第二个（beforeRouteEnter < beforeResolve）这样顺序的queue，

   在执行完毕后，开始执行updateRoute，之后执行全局的afterEach守卫。最后完成路由的跳转。

 ###  其他内容

1. CRP（关键渲染路径）

   * 第一步构造DOM树
   * 然后构造CSSOM树
   * 运行JavaScript
   * 创建渲染树（Render Tree）
   * 生成布局
   * 绘制

2. 从URL输入到页面展现到底发生了什么?

   * DNS解析：将域名解析成IP地址
   * TCP

3. 4

   